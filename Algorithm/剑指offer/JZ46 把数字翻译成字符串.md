# 描述
有一种将字母编码成数字的方式：'a'->1, 'b->2', ... , 'z->26'。

现在给一串数字，返回有多少种可能的译码结果

数据范围：字符串长度满足 

0<n≤90
进阶：空间复杂度 

O(n)，时间复杂度 

O(n)

# 解法 动态规划

思路：

对于普通数组1-9，译码方式只有一种，但是对于11-19，21-26，译码方式有可选择的两种方案，因此我们使用动态规划将两种方案累计。

具体做法：

step 1：用辅助数组dp表示前i个数的译码方法有多少种。
step 2：对于一个数，我们可以直接译码它，也可以将其与前面的1或者2组合起来译码：如果直接译码，则

dp[i]=dp[i−1]；如果组合译码，则

dp[i]=dp[i−2]。
step 3：对于只有一种译码方式的，选上种

dp[i−1]即可，对于满足两种译码方式（10，20不能）则是

dp[i−1]+dp[i−2]
step 4：依次相加，最后的

dp[length]即为所求答案。

go
```
func solve( nums string ) int {
    // write code here
    if len(nums)==0 || nums[0] == '0' {
        return 0
    }
 
//   表示字符串nums中 以i个位置结尾的前缀字符串的解码种数
    dp := make([]int, len(nums))
    // 第一个字符不为0
    //  由于只有一个值（1-9之间），所以，只有一种编码
    //  在第0个字符的时候只有一个字母所以只有一种翻译办法
    dp[0] = 1
 
    // 填充剩余dp数组
    for i:=1; i<len(dp); i++{
        // 当前字符不等于0的时候,dp[i] = dp[i-1]
        // 此时将当前位置的一个字符译码
        if nums[i] != '0' {
            dp[i] = dp[i-1]
        }
 
        // 当前字符与前面一个字符组成的数值
        num := (nums[i-1]-'0')*10 + nums[i]-'0'
        if num >=10 && num <=26 {
            // 第二个字符，特殊处理
            if i==1{
                dp[i] +=1
            }else{
                // 由于前面  dp[i] = dp[i-1]
                // 所以此时相当于 dp[i] = dp[i-1] + dp[i-2]
                dp[i] += dp[i-2]
            }
        }
    }
 
    return dp[len(nums)-1]
}
```