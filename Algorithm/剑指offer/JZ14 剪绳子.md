





# 解 动态规划

思路：

一旦分出一段长度为1的小段，只会减少总长度，还不能增加乘积，因此长度为2的绳子不分比分开的乘积大，长度为3的绳子不分比分开的乘积大，长度为4的绳子分成2*2比较大。前面的我们都可以通过这样递推得到，后面的呢？

同样递推！如果我有一个长度为

n的绳子，我们要怎么确定其分出最大的乘积，我们可以尝试其中一段不可分的为

j，那么如果另一段

n−j最大乘积已知，我们可以遍历所有

j找到这个最大乘积。因此用

dp[i]表示长度为i的绳子可以被剪出来的最大乘积，那么后续遍历每个

j的时候，我们取最大

dp[i]=max(dp[i],j∗dp[i−j])就好了。

//可以被分成两份
for(int j = 1; j < i; j++)
    //取最大值
    dp[i] = max(dp[i], j * dp[i - j]);
具体做法：

step 1：检查当number不超过3的时候直接计算。
step 2：用dp数组表示长度为i的绳子可以被剪出来的最大乘积，初始化前面4个容易推断的。
step 3：遍历每个长度，对于每个长度的最大乘积，可以遍历从1到i的每个固定一段，按照上述公式求的最大值。
step 4：最后数组最后一位就是答案。


go
```
func cutRope( n int ) int {
    // write code here
	 //不超过3直接计算
    if n <=3{
        return n-1
    }
 //dp[i]表示长度为i的绳子可以被剪出来的最大乘积
    var dp = make(map[int]int,n+1)

    dp[1],dp[2],dp[3],dp[4] = 1,2,3,4
//遍历后续每一个长度
    for i:=5;i<=n;i++{
		//可以被分成两份
        for j:=1;j<i;j++{
			//取最大值
            dp[i] = max(dp[i],j*dp[i-j])
        }
    }

    return dp[n]
}

func max(a,b int)int{
    if a>b{
        return a
    }

    return b
}
```