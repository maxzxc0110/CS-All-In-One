# 描述
现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。
有如下规则：
1. A为1，J为11，Q为12，K为13，A不能视为14
2. 大、小王为 0，0可以看作任意牌
3. 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。
4.数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]

要求：空间复杂度 
�
(
1
)
O(1)，时间复杂度 
�
(
�
�
�
�
�
)
O(nlogn)，本题也有时间复杂度 
�
(
�
)
O(n) 的解法

# 解法 哈希表

思路：

题中给出的信息是两副牌，因此最多4个零，因此必有一张非零牌，分析顺子两点基本情况：

不能有重复的非零牌
非零牌之间最大相差为4
可以找到这手牌的最大差值，若是两张非零牌最大相差大于4，则需要4张零牌（超出了限制）来填充中间的部分，若是小于等于4，又不重复的情况下，要么零牌补齐，要么本身就是相邻的数字。

因此创建一个哈希表，查找重复：遍历数组的同时，遇到非零牌重复，直接不行，若没有重复则加入到哈希表中，等待后续的查找。同时在遍历过程需要记录数组最大值与最小值，最后检查最大值与最小值的差是否大于4，小于4的话，在没有非零牌重复的情况下，最大值与最小值中间的牌加上0牌就可以填满这手顺子。

具体做法：

step 1：创建一个哈希表统计这手牌有无非零重复牌。
step 2：使用两个变量记录这手牌的上下界。
step 3：遍历每一张牌，零牌可以重复，非零牌重复则不能为顺子。用哈希表检查去重。
step 4：将新牌加入哈希表，并更新这手牌的上下界。
step 5：最后检查上下界之差是否大于等于5，若是则构不成顺子，否则可以。
go

```
func IsContinuous(numbers []int) bool {
	// write code here
	var hash = make(map[int]int)
	max, min := 0, 13
	for i := 0; i < len(numbers); i++ {
		if numbers[i] > 0 {

			if hash[numbers[i]] > 1 {
				return false
			} else {
				hash[numbers[i]]++
				if numbers[i] >= max {
					max = numbers[i]
				}

				if numbers[i] <= min {
					min = numbers[i]
				}
			}
		}
	}

	if (max - min) >= 5 {
		return false
	}

	return true

}

```