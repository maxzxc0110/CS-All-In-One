# 描述
有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。

数据范围：
1
≤
�
≤
10000
1≤n≤10000，数组中任意元素的值: 
0
≤
�
�
�
≤
10000
0≤val≤10000
要求：空间复杂度：
�
(
1
)
O(1) ，时间复杂度：
�
(
�
�
�
�
)
O(logn)

# 解法


思路：

旋转数组将原本有序的数组分成了两部分有序的数组，因为在原始有序数组中，最小的元素一定是在首位，旋转后无序的点就是最小的数字。我们可以将旋转前的前半段命名为A，旋转后的前半段命名为B，旋转数组即将AB变成了BA，我们想知道最小的元素到底在哪里。

因为A部分和B部分都是各自有序的，所以我们还是想用分治来试试，每次比较中间值，确认目标值（最小元素）所在的区间。

具体做法：

step 1：双指针指向旋转后数组的首尾，作为区间端点。
step 2：若是区间中点值大于区间右界值，则最小的数字一定在中点右边。
step 3：若是区间中点值等于区间右界值，则是不容易分辨最小数字在哪半个区间，比如[1,1,1,0,1]，应该逐个缩减右界。
step 4：若是区间中点值小于区间右界值，则最小的数字一定在中点左边。
step 5：通过调整区间最后即可锁定最小值所在。


go
```
func minNumberInRotateArray( nums []int ) int {
    // write code here
    left := 0
    right := len(nums) - 1

    for left < right{
        mid := (left + right) / 2
        if nums[mid] > nums[right]{
            left = mid + 1
        }else if nums[mid] == nums[right]{
            right--
        }else{
            right = mid
        }
    }

    return nums[left]

}
```